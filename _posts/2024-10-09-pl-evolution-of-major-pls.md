---
layout: post
title: "Concepts of Programming Languages 02: Evolution of the Major Programming Languages"
date: 2024-10-09 12:23 +0900
description: 
image:
  path: /assets/img/contents/pl_history.jpg
  alt: history of PLs
category: [Computer Science, Concepts of Programming Languages]
tags: [Programming Languages, History]
pin: false
math: true
mermaid: true
toc: true
---

<h2>1. Fortran</h2>  
1. Fortran 0  
    구현되지 않았다. 설계만 된 언어이다.  
2. **Fortran 1**  
    index register와 부동소수점 h/w가 지원되는 IBM 704 컴퓨터에서 작동되도록 설계된 언어이다.  
    이러한 h/w적인 변화는 Compiled 프로그래밍 언어(포트란 1)의 등장을 초래하였다.  
    Fortran 개발 당시 제약이 굉장히 많았다. 동적 할당을 위한 메모리 공간이 없었고, loop를 핸들링하고, 카운팅하기 위한 배열도 없었다. 명시적으로 integer type을 지원하는 변수명이 존재했고, 나머지는 floating-point를 명시적으로 나타냈다. 또한, 문자열을 다루는 방법도 없었으며, 사무용으로 사용하기 위한 I/O도 없었다.  

    이러한 환경을 배경으로, Fortran 1이 구현되었는데, 의의는 다음과 같다.  
    - **최초의 고급언어이다.**  
    - **매우 빠르다.** 
    - name(ex. 변수명) 최대 6글자 지원, DO 계열의 loop문 지원, formatted I/O, 사용자 정의 subprogram, arithmetic IF 지원, 자료형은 없었다.
    - 특별한 컴파일러가 없었다가 개발되었는데 400줄이 넘어가면 컴파일이 안 되는 한계를 지니고 있었다.  
    - 꽤나 널리 보급되었다. 현재도 사용할만큼 꽤나 강력한 언어 중 하나이다.  
3. Fortran 2  
    큰 변화X, 버그 수정
4. Fortran 4  
    명시적 타입 선언 지원, 논리적 조건문 지원, subprogram(ex. 함수)의 이름을 parameter로 사용할 수 있도록 지원, ANSI의 표준으로 등록  
5. Fortran 77  
    문자열 핸들링 지원, 논리 연산을 통해 loop 컨트롤 지원, IF-THEN-ELSE문 지원  
6. Fortran 90  
    모듈, 동적 배열, 포인터, 재귀, CASE 문, 파라미터 타입 체크 지원
7. Fortran 95, Fortran 2003 (2023년 버전이 최신 버전으로 알고 있다.)  

포트란 언어의 최종적인 의의는 다음과 같다.  
- 컴파일러가 매우 최적화가 잘 된 언어이다.  
- 누구나 컴퓨터를 사용할 수 있도록 컴퓨터를 사용하는 방식을 바꾸는데 기여하였다.  

<h2>2. LISP(함수형 프로그래밍)</h2>  
LISP는 LISt Processing language의 약자로, AI 연구에서 보통 list 기반의 자료형 처리, numeric보다 symbolic에 대한 연산이 주를 이루기 때문에 AI 연산에 특화된 언어 설계를 목표로 하여 만들어진 언어의 종류이다.  
atom과 list라는 오직 두 가지 자료형만 제공하며, labmda 함수 기반의 문법을 제공한다.  
Link-List를 사용해서 데이터를 처리하며, 전위 표기법을 사용하는 것이 큰 특징이며, 어떠한 변수나 할당자도 필요하지 않다.  
지금의 함수형 프로그래밍 방법론의 전신이 되는 언어 종류라고 보면 되며, 현재는 개선된 LISP 언어 계열로 Scheme와 Common LISP가 있다.  

1. Scheme  
    작고, static scoping을 사용하는 것이 특징이다.  
    함수를 기본 단위를 사용하고, 단순한 문법을 사용하여 교육적인 목적으로도 사용한다.  
2. Common LISP  
    매우 크고, 복잡하며, LISP의 변조 언어들의 특징을 하나로 모은 언어이다.  

<h2>3. ALGOL</h2>  
> ALGOL 60(최초 ALGOL 언어)은 Universal Language를 디자인하려는 노력의 결과물이다.  

ALGOL 언어는 현실의 수학적인 표현과 비슷한 언어를 만드려고 노력했으며, 알고리즘을 설명하는데 좋은 언어를 만드려고 했고, machine code로 번역할 수 있는 언어를 만드려고 노력했다.  

ALGOL 언어의 특징은 다음과 같다.  
- type(자료형)의 개념이 형식화 되었다.
- 이름의 길이에 제한이 없었다.
- 배열 차원에 제한이 없었다. (Subscript 개수 제한 X)
- 파라미터가 in-mode, out-mode로 분리되어 지원되었다.
- Subscript가 [] (bracket)으로 표현되었다.
- 복합문을 지원하였다.
- 세미콜론을 통해 statement를 구분하였다.
- 할당연산자가 := 이다.
- if와 if-else를 지원하였다.
- machine 독립적인 언어를 위해 I/O는 구현하지 않았다.

ALGOL 58은 구현되지 않아서 설명은 생략하였다.(IBM에서 Fortran 밀어주려고 지원을 끊어서 구현까지 못 갔다는 게 정설이다.)  

**[ALGOL 60]**  
- 기존 ALGOL 58에서 새로워진 특징 몇 가지를 소개한다.  
- 블록 구조 지원
- 파라미터 개수를 2개로 제한하였다.
- subprogram 재귀가 가능하였다.
- 스택 동적 배열을 지원하였다.
- 여전히 I/O는 지원하지 않고, 문자열 핸들링에 대한 지원이 없었다.  

**[ALGOL의 성공, 의의]**  
1. 알고리즘을 표현하는 언어로서 20년 이상 꾸준히 사용되었다.
2. 모든 명령형 프로그래밍 언어의 기반이 되었다.
3. 첫 기계 독립적인 언어이다.
4. 최초로 BNF가 적용된 문법을 사용한 언어이다.

=> 뭔가 시험에 출제하기 딱 좋은 의의를 지니고 있는 언어이다. 잘 기억해두자.  

**[ALGOL의 한계 - 널리 사용되지 못한 이유]**  
1. I/O 구현 X => 입출력을 전부 언어 사용자에게 맡겼다. (그냥 Readability, Writability, Reliability, Cost 전부 다 떨어뜨린 셈이다.)  
2. character set (문자열)에 대한 지원을 하지 않았다.  
3. 너무 유연한 언어 설계 탓에, 구현이 매우 힘들었다.  
4. 당시엔 BNF 문법에 대한 이해가 어려웠다.  
5. IBM의 지원 중단과 Fortran의 강세로 인해 널리 사용되지 못했다.  

<h2>4. COBOL</h2>  
> 최초로 사무용으로 개발된 언어이다.  

등장 배경은 생략하겠다. FLOW-MATIC의 특징에 기반해서 모든 코드의 첫 단어가 동사임을 기억하자.  

**[COBOL의 디자인 목표]**   
1. 단순한 영어처럼 보여야 한다.
2. 덜 효율적이라도 사용하기 쉬워야 한다.
3. 컴퓨터를 사용하는 누구라도 사용할 수 있어야 한다.
4. 당시 컴파일러 문제에 구애받지 않아야 한다.  

**[COBOL 언어의 의의]**  
1. 처음으로 고급언어(high-level language)에 macro facility 개념을 등장시켰다.  
2. records라는 계층적 데이터 구조를 사용하였다.  
3. 중첩 선택 구문을 지원하였다.  
4. 하이픈을 포함해 최대 30자까지 긴 이름을 사용할 수 있었다.  
5. "코드 영역과 데이터 영역의 구분"을 지원하였다.  

<h2>5. BASIC</h2>  
> 최초로 time sharing(시분할) 개념을 도입한 언어이다.  

그닥 중요하게 다루는 언어는 아니다 보니 위의 특징만 기억하면 될 듯 하지만,  
추가적인 설명을 하자면, 이름에서도 알 수 있듯이 BASIC에서 파생된 언어는 Visual Basic이다. (윈도우 PC 모의 해킹할 때 다뤄봤는데, 개인적으로 코드 작성하면서 신기했던 경험이 있다.)  
디자인 목표는 친근한 언어, 혼자서도 이용 가능한 언어, 사용자 친화적인 언어를 설계하는 것이었다고 한다.  

<h2>6. PL/1</h2>  
등장 배경을 조금 알아야 할 필요가 있다. 
당시, IBM에서 거의 독점적으로 컴퓨터를 공급하고 있었으며,  
과학 도메인 쪽에서는 FORTRAN을, 비즈니스(사무) 도메인에서는 COBOL을 사용하고 있었다.  
결론부터 얘기하면, FORTRAN 언어에서 구현된 기능이 비즈니스 도메인에서 필요했고, COBOL 언어에서 구현된 기능이 과학 도메인에서 필요했던 것이다.  
예를 들어, 과학 분야에서 FORTRAN을 사용하고 있는 유저는 COBOL의 정교한 I/O 가 필요했고, 사무 분야에서 COBOL을 사용하고 있는 유저는 FORTRAN의 부동 소수점, 배열 등이 필요했다.  
따라서, IBM은 두 도메인의 니즈를 충족시킬 새로운 컴퓨터와, 두 언어의 특징을 결합한 새로운 언어의 필요성을 느껴 PL/1을 개발한 것이다.  

**[PL/1의 의의, 기여한 점]**
1. 최초로 사용자 레벨에서 concurrency(동시성)을 지원하였다. 다른 말로 해석하면, 동시에 실행할 수 있는 subprogram을 생성할 수 있게 되었다.  
2. 최초로 error-handling 기능을 지원하였다.  
3. switch문의 재귀적 사용 기능을 지원하였다.   
4. `최초로 포인터 데이터 타입`을 지원하였다.  
5. 최초로 array cross sections을 지원하였다. 배열의 일부분을 참조할 수 있게 되었다는 의미이다. (아래 C언어 예시로 이해)
```c
int a[5][5];
a[1] // 5*5배열의 두 번째 행을 참조
```  

**[PL/1의 한계, 문제점]**  
- 너무 많은 기능을 포함하다보니 굉장히 거대하고 복잡하고 잘 설계된 언어가 아니게 되버렸다. (Readability 떨어지는 문제점)  

<h2>7. APL & SNOBOL</h2>  
의의는 최초의 동적 언어이다. (동적 typing과 동적 allocation이 가능하다.)
- APL : 연산자가 많아 가독성이 떨어지지만 행렬 연산 작성이 매우 편했다.  
- SNOBOL : 문자열 패턴 매칭에 강력한 연산자를 제공한다.  

<h2>8. SIMULA 67 & ALGOL 68</h2>  
- SIMULA 67은 최초로 데이터 추상화의 개념이 도입된 언어이다. (Coroutines라고 해서 subprogram의 종류를 최초로 도입했고, 클래스와 객체 그리고 상속의 개념을 처음으로 도입한 언어이다.)  
- ALGOL 68은 Orthogonality를 목표로, 사용자 정의 데이터 구조 및 동적 배열 개념을 최초로 도입했다는데 의의가 있다.  

<h2>9. Pascal</h2>
structured programming(구조적 프로그래밍)을 가르치기 위해 설계뙨 언어이며, 굉장히 간단하다는 특징이 있다.  

<h2>10. C</h2>
10번째에 와서야 C언어가 등장한다.  
시스템 프로그래밍을 위해 설계된 언어이며, 강력한 연산자를 제공하지만 type check를 제공하지 않는 단점이 있다.  
UNIX를 만든 언어로 유명하며, UNIX 기반으로 퍼져나갔다.    

<h2>11. Prolog</h2>
절차지향적이지 않고, 'formal logic'을 기반으로 설계된 언어이다. 비효율적이다. 넘어가도록 하자.  

<h2>12. Ada & Ada 95</h2>
기여한 점이 많다.  
1. `패키지` 지원 (데이터 추상화 지원)
2. 정교한 예외처리 기능 지원
3. Generic programming을 지원 (C++의 template)
4. tasking model을 통한 동시성 지원

후에 Ada 95를 통해 OOP를 지원, 공유 데이터에 대한 더 나은 통제 매커니즘 제공, 새로운 동시성 기능, 더 유연한 라이브러리 제공 등 힘을 썼지만, C++의 등장으로 밀려난 언어이다.  

<h2>14. OOP 언어 역사 총정리</h2>
1) Smalltalk  
  처음으로 완전한 객체지향 언어의 개념이 구현된 언어이다.  
  cf. 완전한 OOP: 데이터 추상화, 상속, 동적 바인딩  

2) C++  
  C와 SIMULA 67의 영향을 받아 설계된 언어로, OOP 개념을 도입, 예외처리 제공, 객체지향과 절차지향을 모두 지원했다는 특징이 있다.(방대하고, Window OS나 게임엔진 등에 쓰인다.)  

3) JAVA  
  C++이 범용적으로 사용하기 힘들고 신뢰성이 낮다는 문제가 있어, 신뢰성에 악영향을 주는 요소인 pointer, union, enum 등을 제외시키고, 오로지 OOP 개념만을 도입한 언어인 것이 특징이다. (C++은 신뢰성이 낮아 가전기기와 같은 임베디드 시스템의 프로그래밍에는 적합하지 않았다.)  
  초기엔 applet을 통해 동시성을 제공했으나 지금은 thread를 이용한다.  
  JVM을 통해 범용성을 보장하였고, 웹프로그래밍에도 쓰이는 것이 특징이다.  

<h2>15. WEB을 위한 스크립트 언어 총정리</h2>  
스크립트 언어는 전부 인터프리터 기반의 언어인 것이 특징이다.  
1) Perl  
  안전성, 신뢰성이 낮은 특징이 있으며, 웹이나 UNIX 등에 이용한다.  
2) JavaScript  
  Client-Side에서 HTML에 임베딩하여 사용하는 언어이며, Client-Side에서 인터프리팅되는 특징을 지니고 있다.  
3) PHP  
  Server-Side에서 HTML에 임베딩하여 사용하는 언어이며, Server-Side에서 인터프리팅되는 특징을 지니고 있다.  
4) Python  
  너무 유명하다. 타입 체크 지원, 동적으로 타입이 정해진다.  
  넘어가도록 하자.  
5) Lua  
  주로 게임 프로그래밍에 사용되는 것이 특징이며, 확장성이 좋다는 것이 특징이다.  
6) Ruby  
  Perl과 Python을 대체하기 위해 나온 언어로, 순수 OOP 언어이다.  

<h2>16. 이외</h2>  
1) C#  
  .NET 프로젝트에서 개발한 언어, CTS(Common Type System)을 사용하는 것이 특징이다.  
2) Markup / Programming Hybrid Languages  
  - XSLT: XML이 확장된 마크업 언어라면, XSLT는 XML 문서를 보여주기 위해 변환하며, 루프와 같은 프로그래밍 요소를 가지고 있다.  
  - JSP: Java Serve Pages의 약자로, 동적 웹 페이지를 만드는데 사용하는 기술이다. (JSTL은 JSP에서 사용하는 라이브러리이다.)  